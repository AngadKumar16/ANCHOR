#!/usr/bin/env python3
"""
Tools/ai_features.py

- If no backend detected, create a minimal FastAPI scaffold under ./backend/
- Otherwise read plan.md and create the first *unchecked* feature (one feature per run)
  by generating:
    - <Feature>View.swift
    - <Feature>ViewModel.swift
- Supports --dry-run, --commit, --debug
- Writes debug log to ~/.ai-fix-issues/features.log when --debug is set
"""
from __future__ import annotations
import argparse
import os
import re
import subprocess
import time
import shutil
from pathlib import Path
from typing import List, Tuple

# --- configuration ---
HOME = str(Path.home())
DEBUG_LOG_DIR = os.path.join(HOME, ".ai-fix-issues")
os.makedirs(DEBUG_LOG_DIR, exist_ok=True)
DEBUG_LOG = os.path.join(DEBUG_LOG_DIR, "features.log")

# default timeouts (seconds)
SEARCH_TIMEOUT = 6
GREP_TIMEOUT = 6
RUN_CMD_TIMEOUT = 20

# --- logging helper ---
def dlog(msg: str, debug: bool = False):
    line = str(msg).rstrip()
    print(line)
    if debug:
        try:
            with open(DEBUG_LOG, "a", encoding="utf8") as f:
                f.write(time.strftime("%Y-%m-%d %H:%M:%S ") + line + "\n")
        except Exception:
            pass

# --- robust command runner preferring rg (ripgrep) ---
def run_cmd(cmd: List[str], input_text: str = None, cwd: str = None, timeout: int = RUN_CMD_TIMEOUT) -> Tuple[int, str, str]:
    """
    Run command (list). Returns (rc, stdout, stderr).
    """
    try:
        proc = subprocess.run(cmd, input=input_text, text=True, capture_output=True, check=False, cwd=cwd, timeout=timeout)
        return proc.returncode, proc.stdout or "", proc.stderr or ""
    except subprocess.TimeoutExpired:
        return 124, "", "Command timed out"
    except Exception as e:
        return 1, "", str(e)

def search_repo(term: str, timeout: int = SEARCH_TIMEOUT) -> Tuple[int, str, str]:
    """
    Search the repo for a term. Use 'rg' if present; otherwise use grep -R.
    Excludes common heavy directories.
    """
    rg = shutil.which("rg")
    if rg:
        cmd = [rg, "--line-number", "--hidden", "--glob", "!.git/**", "--glob", "!DerivedData/**", "--glob", "!node_modules/**", "-n", term, "."]
        return run_cmd(cmd, timeout=timeout)
    else:
        # fallback: grep with excludes
        cmd = ["grep", "-R", "--line-number", "--exclude-dir=.git", "--exclude-dir=DerivedData", "--exclude-dir=node_modules", "-n", term, "."]
        return run_cmd(cmd, timeout=timeout)

# ---------- Backend detection + ensure ----------
def repo_has_backend() -> bool:
    candidates = ["backend", "server", "api", "app.py", "requirements.txt", "backend/app.py", "backend/Dockerfile"]
    for c in candidates:
        if os.path.exists(c):
            return True
    # quick content search for common backend frameworks
    rc, out, err = search_repo(r"FastAPI|uvicorn|flask|django|express|Vapor|http.server", timeout=4)
    if rc == 0 and out.strip():
        return True
    return False

def ensure_backend(dry: bool, debug: bool) -> List[str]:
    created = []
    if repo_has_backend():
        dlog("Backend detected; skipping backend creation.", debug)
        return created

    dlog("Backend not detected; will create minimal FastAPI scaffold under ./backend/", debug)
    created = ["backend/", "backend/app.py", "backend/requirements.txt", "backend/Dockerfile"]
    if dry:
        for p in created:
            dlog(f"[dry-run] would create: {p}", debug)
        return created

    os.makedirs("backend", exist_ok=True)
    app_py = """from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"status": "ok", "msg": "Backend running"}
"""
    reqs = "fastapi\nuvicorn[standard]\n"
    dockerfile = """FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD [ "uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000" ]
"""
    with open("backend/app.py", "w", encoding="utf8") as f:
        f.write(app_py)
    with open("backend/requirements.txt", "w", encoding="utf8") as f:
        f.write(reqs)
    with open("backend/Dockerfile", "w", encoding="utf8") as f:
        f.write(dockerfile)
    for p in created:
        dlog("Created " + p, debug)
    return created

# ---------- plan parsing & detection ----------
def load_plan_unchecked(path: str = "plan.md") -> List[str]:
    """
    Return a list of unchecked checklist items from plan.md (in order).
    - matches lines like "- [ ] Feature name", "* [ ] Feature name", "1. [ ] Feature name"
    If none found, fall back to non-empty non-heading lines (bullets/headings ignored).
    """
    if not os.path.exists(path):
        return []
    text = Path(path).read_text(encoding="utf8")
    # find unchecked checklist items
    unchecked_pattern = re.compile(r'^[\s\-\*\d\.\)]*\[\s*\]\s*(.+)$', re.MULTILINE)
    items = [m.strip() for m in unchecked_pattern.findall(text)]
    if items:
        return items
    # fallback: collect non-heading non-empty lines (strip bullets)
    lines = []
    for raw in text.splitlines():
        s = raw.strip()
        if not s or s.startswith("#"):
            continue
        m = re.match(r'^[\-\*\d\.\)]\s*(.+)$', s)
        lines.append(m.group(1).strip() if m else s)
    return lines

def tokens_for_feature(feature: str) -> List[str]:
    words = re.findall(r"[A-Za-z0-9_]+", feature)
    tokens = [w.lower() for w in words if len(w) >= 4]
    if not tokens:
        tokens = [w.lower() for w in words][:2]
    return tokens[:3]

def feature_present_in_repo(feature: str) -> bool:
    tokens = tokens_for_feature(feature)
    if not tokens:
        return False
    for t in tokens:
        rc, out, err = search_repo(t, timeout=4)
        if rc == 0 and out.strip():
            return True
    return False

# ---------- file generation helpers ----------
def safe_name_from_feature(feature: str) -> str:
    base = re.sub(r"[^A-Za-z0-9 ]+", "", feature).strip()
    base = "".join(word.capitalize() for word in base.split())
    if not base:
        base = "Feature"
    if not base.endswith("View"):
        base = base + "View"
    return base

def choose_target_dir() -> str:
    # prefer existing candidates; otherwise create App/Features
    candidates = ["App/Features", "Sources", "App"]
    for cand in candidates:
        if os.path.exists(cand):
            return cand
    default = "App/Features"
    os.makedirs(default, exist_ok=True)
    return default

def make_view_and_viewmodel(feature: str) -> Tuple[str, str, str, str]:
    """
    Returns (view_path, view_contents, vm_path, vm_contents)
    """
    base = safe_name_from_feature(feature)
    target_dir = choose_target_dir()
    view_path = f"{target_dir}/{base}.swift"
    vm_name = base.replace("View", "ViewModel")
    vm_path = f"{target_dir}/{vm_name}.swift"

    vm_contents = f"""import Foundation
import Combine

/// Auto-generated ViewModel for '{feature}'
final class {vm_name}: ObservableObject {{
    @Published var title: String = "{feature}"
    @Published var items: [String] = []

    private var cancellables = Set<AnyCancellable>()

    init() {{
        // Provide mock data for previews
        self.items = ["Sample 1", "Sample 2"]
    }}

    /// Placeholder async loader
    func load() async {{
        // TODO: implement real loading from repository / backend
        try? await Task.sleep(nanoseconds: 200_000_000) // 0.2s simulated delay
        DispatchQueue.main.async {{
            self.items = ["Loaded item 1", "Loaded item 2"]
        }}
    }}
}}
"""
    # note: escape backslash before .self properly inside Python triple-quoted string
    view_contents = f"""import SwiftUI

// Auto-generated View for feature: {feature}
struct {base}: View {{
    @StateObject private var viewModel = {vm_name}()

    var body: some View {{
        NavigationView {{
            VStack {{
                Text(viewModel.title)
                    .font(.largeTitle)
                    .padding(.top)

                if viewModel.items.isEmpty {{
                    VStack {{
                        Text("No items yet")
                            .foregroundColor(.secondary)
                        ProgressView()
                            .padding(.top, 8)
                    }}
                }} else {{
                    List(viewModel.items, id: \\\\.self) {{ item in
                        Text(item)
                    }}
                }}

                Spacer()
            }}
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {{
                ToolbarItem(placement: .navigationBarTrailing) {{
                    Button(action: {{
                        Task {{
                            await viewModel.load()
                        }}
                    }}) {{
                        Image(systemName: "arrow.clockwise")
                    }}
                    .accessibilityLabel("Refresh")
                }}
            }}
            .padding()
        }}
    }}
}}

#if DEBUG
struct {base}_Preview: PreviewProvider {{
    static var previews: some View {{
        {base}()
            .previewDevice("iPhone 14")
    }}
}}
#endif
"""
    return view_path, view_contents, vm_path, vm_contents

def write_with_backup(path: str, contents: str, debug: bool):
    if os.path.exists(path):
        ts = int(time.time())
        bak = f"{path}.bak.{ts}"
        try:
            os.replace(path, bak)
            dlog(f"Backed up existing {path} -> {bak}", debug)
        except Exception as e:
            dlog(f"Backup failed for {path}: {e}", debug)
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    with open(path, "w", encoding="utf8") as f:
        f.write(contents)
    dlog(f"Wrote {path}", debug)

def git_commit(paths: List[str], msg: str, debug: bool) -> bool:
    if not paths:
        dlog("No paths to commit.", debug)
        return False
    rc, out, err = run_cmd(["git", "add"] + paths)
    if rc != 0:
        dlog(f"git add failed: {err}", debug)
        return False
    rc, out, err = run_cmd(["git", "commit", "-m", msg])
    if rc != 0:
        dlog(f"git commit failed: {err}", debug)
        return False
    dlog(f"Committed: {msg}", debug)
    return True

# ---------- main ----------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--dry-run", action="store_true", help="Don't write files")
    parser.add_argument("--commit", action="store_true", help="git add & commit changes")
    parser.add_argument("--debug", action="store_true", help="Write debug log")
    args = parser.parse_args()

    dry = args.dry_run
    do_commit = args.commit
    debug = args.debug

    # 1) backend
    if not repo_has_backend():
        created = ensure_backend(dry, debug)
        if created:
            dlog(f"Backend scaffold created (or would be): {created}", debug)
            if do_commit and not dry:
                git_commit(created, "AI-features: create backend scaffold", debug)
        else:
            dlog("No backend files created.", debug)
        return

    # 2) plan -> first unchecked item
    plan_items = load_plan_unchecked()
    if not plan_items:
        dlog("plan.md not found or contains no items to process. Nothing to do.", debug)
        return

    dlog(f"plan.md contains {len(plan_items)} unchecked/target items; scanning for first missing feature...", debug)
    target_feature = None
    for item in plan_items:
        # skip short lines or headings
        if not item or len(item.strip()) < 3:
            continue
        if feature_present_in_repo(item):
            dlog(f"Feature already present (skipping): {item}", debug)
            continue
        target_feature = item
        break

    if not target_feature:
        dlog("No missing frontend features found in plan.md (all present according to heuristics).", debug)
        return

    dlog("Will implement one feature this run: " + target_feature, debug)
    view_path, view_contents, vm_path, vm_contents = make_view_and_viewmodel(target_feature)

    if dry:
        dlog(f"[dry-run] Would create: {view_path}", debug)
        dlog(f"[dry-run] Would create: {vm_path}", debug)
        return

    # write files with backups
    write_with_backup(view_path, view_contents, debug)
    write_with_backup(vm_path, vm_contents, debug)
    created = [view_path, vm_path]

    if do_commit:
        ok = git_commit(created, f"AI-feature: add {target_feature}", debug)
        if not ok:
            dlog("Commit failed for feature files.", debug)
    else:
        dlog(f"Created feature files: {created} (not committed).", debug)

if __name__ == "__main__":
    main()
